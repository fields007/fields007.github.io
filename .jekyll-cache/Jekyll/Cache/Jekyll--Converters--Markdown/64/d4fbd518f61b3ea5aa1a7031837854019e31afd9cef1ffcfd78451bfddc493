I"d:<h1 id="power-sets">power sets</h1>
<p>The power set of a set is the set of all its subsets, or a collection of all the different combinations of items
contained in that given set: in this write-up, we’ll briefly explore the math behind power sets, and derive and compare
three different algorithms used to generate them.</p>

<h2 id="sets-primer">sets: primer</h2>
<p>To refresh our memories: a <a href="http://en.wikipedia.org/wiki/Set_(mathematics)">set</a>, the building block of <a href="http://en.wikipedia.org/wiki/Set_theory">set
theory</a><sup id="link1"><a href="#note1">1</a></sup>, is a collection of any number of
unique objects whose order does not matter. A set is expressed using bracket notation, like \(\{1, 2, 3\}\), and an
empty, or <strong>null</strong>, set is represented using either of \(\emptyset\) and \(\{\}\). Because sets are order-agnostic, we
can say that the \(\{1, 2, 3\}\) and \(\{3, 1, 2\}\) are equal, and, because they contain only distinct members,
something like \(\{1, 1, 2\}\) is invalid.</p>

<h2 id="subsets-and-the-power-set">subsets and the power set</h2>
<p>The <a href="http://en.wikipedia.org/wiki/Subset">subset</a> of a set is any combination (the null set included) of its members,
such that it is contained inside the superset; \(\{a, b\}\), then, is a subset of \(\{a, b, c\}\), while \(\{a, d\}\)
is not. If a subset contains <em>all</em> of the members of the parent set (ie, it’s a copy), we call it an <strong>improper</strong>
subset – otherwise, it’s <strong>proper</strong>. Finally, the <a href="http://en.wikipedia.org/wiki/Power_set">power set</a> of a set is the
collection of all of its subsets, so the power set of \(\{a, b, c\}\) is:</p>

\[\{
    \{\},
    \{a\},
    \{b\},
    \{c\},
    \{a, b\},
    \{a, c\},
    \{b, c\},
    \{a, b, c\}
\}\]

<h2 id="the-cardinality-of-a-power-set">the cardinality of a power set</h2>
<p>The length, or <a href="http://en.wikipedia.org/wiki/Cardinality">cardinality</a>, of a power set is \(2^n\), where \(n\) is the
cardinality of the original set, so the number of subsets of something like \(\{a, b, c\} (n=3)\) is 8 \((2^{n=3})\).
Two ways of informally proving that property:</p>

<ol>
  <li>when creating a subset of a given set, we iterate over the members of the given set and choose whether each one
will or will not be in the subset. Since there are 2 possible outcomes of each choice (the member either is or
isn’t chosen) and there are \(n\) elements, there must be \(2^n\) subsets.</li>
  <li>when adding an element to a set, to update its power set, you must create a copy of each of its existing subsets
with the new element included. We’ll use this to implement our succinct second algorithm.</li>
</ol>

<p><strong>Note</strong>: the following algorithms are accompanied by Python implementations. To keep things simple, and because the
algorithms are language-independent, I avoided using Python-specific built-ins (like <code class="language-plaintext highlighter-rouge">yield</code>) and functions (like
<code class="language-plaintext highlighter-rouge">list.extend()</code>) that don’t have clear equivalents in most other languages, even though they would’ve made some code
much cleaner. Also, even though we’re dealing with sets, we’ll use lists (arrays) under the assumption that they
contain distinct elements.</p>

<h1 id="algorithm-1-recursive-k-subsets">algorithm 1: recursive k-subsets</h1>
<p>This was my first stab at an algorithm that, given a set, returns its power set, and surprise! It’s the least
intuitive and most inelegant of the three. We begin by writing a recursive function <code class="language-plaintext highlighter-rouge">k_subsets()</code> to find all of a
set’s subsets of cardinality \(k\) (a.k.a. its <a href="http://mathworld.wolfram.com/k-Subset.html">\(k\)-subsets</a>):</p>

<h2 id="generating-k-subsets">generating k-subsets</h2>

<ol>
  <li>Given a set of length \(n\) and a desired subset of length \(k\), iterate over the first \(n - k + 1\) elements.</li>
  <li>For each element, make a recursive call to retrieve the \((k-1)\)-subsets for the remainder of the array (all
elements after the current one).</li>
  <li>Append the element to each \((k-1)\)-subset, and return these subsets.</li>
</ol>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">k_subsets</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">set_</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[[]]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">subsets</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">set_</span><span class="p">)</span> <span class="o">-</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">subset</span> <span class="ow">in</span> <span class="n">k_subsets</span><span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">set_</span><span class="p">[</span><span class="n">ind</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]):</span>
                <span class="n">subsets</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">subset</span> <span class="o">+</span> <span class="p">[</span><span class="n">set_</span><span class="p">[</span><span class="n">ind</span><span class="p">]])</span>
        <span class="k">return</span> <span class="n">subsets</span></code></pre></figure>

<h2 id="from-k-subsets-to-power-set">from k-subsets to power set</h2>

<p>With the ability to generate any \(k\)-subset, the key to creating a power set is finding the \(k\)-subsets for all
valid \(k\), which lie in the range \([0, n]\) (\(n\), again, is the cardinality of the superset)!</p>

<ol>
  <li>For any \(k\) in \([0, n]\):</li>
  <li>find the set’s \(k\)-subsets</li>
</ol>

<p>We’ll introduce a wrapper function, <code class="language-plaintext highlighter-rouge">power_set()</code>, in which we’ll nest a slightly modified <code class="language-plaintext highlighter-rouge">k_subsets()</code> that takes
advantage of closures.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">power_set_1</span><span class="p">(</span><span class="n">set_</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">k_subsets</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">start_ind</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[[]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">subsets</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">start_ind</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">set_</span><span class="p">)</span> <span class="o">-</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">subset</span> <span class="ow">in</span> <span class="n">k_subsets</span><span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ind</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">subsets</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">subset</span> <span class="o">+</span> <span class="p">[</span><span class="n">set_</span><span class="p">[</span><span class="n">ind</span><span class="p">]])</span>
            <span class="k">return</span> <span class="n">subsets</span>

    <span class="n">subsets</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">set_</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">subset</span> <span class="ow">in</span> <span class="n">k_subsets</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">subsets</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">subset</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">subsets</span></code></pre></figure>

<h1 id="algorithm-2-iterative-appending">algorithm 2: iterative appending</h1>

<p>The second algorithm relies on our second informal proof of sets’ cardinality: whenever an element is added to a set,
it must be added to copies of all the subsets in its current power set to form the new one. Thus:</p>

<ol>
  <li>Start with an empty set, \(\{\}\), and its power-set, \(\{\{\}\}\).</li>
  <li>For every element inside the superset:</li>
  <li>Create a copy of every set in the current power-set</li>
  <li>Add the element to each one.</li>
  <li>Add the copies to the current power-set.</li>
</ol>

<p>Like so:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">power_set_2</span><span class="p">(</span><span class="n">set_</span><span class="p">):</span>
    <span class="n">subsets</span> <span class="o">=</span> <span class="p">[[]]</span>
    <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">set_</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">ind</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">subsets</span><span class="p">)):</span>
            <span class="n">subsets</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">subsets</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">element</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">subsets</span></code></pre></figure>

<h1 id="algorithm-3-binary-representation">algorithm 3: binary representation</h1>

<p>The third algorithm is a clever hack, and relies on the binary representation of an incremented number to construct
subsets. In our first proof of the cardinality of a power set, we iterated over each element of an argument set and
made a choice with two possible outcomes (the element either was or wasn’t a member of the subset): \(\underbrace{2 \times 2 \times ... \times 2}_{n} = 2^n\). Let’s consider an integer of \(n\)-bits: it has \(2^n\)
possible values in the range \([0, 2^n - 1]\), meaning that we can use it to represent \(2^n\) distinct arrangements of
\(n\) bits. Hmm…</p>

<ol>
  <li>Iterate over the range \([0, 2^n - 1]\).</li>
  <li>For every value, examine each of its \(n\) bits.</li>
  <li>If the \(k\)th bit has a value of 1, add the \(k\)th value of the superset to the current subset.</li>
</ol>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">is_bit_flipped</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="n">bit</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">num</span> <span class="o">&gt;&gt;</span> <span class="n">bit</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span>

<span class="k">def</span> <span class="nf">power_set_3</span><span class="p">(</span><span class="n">set_</span><span class="p">):</span>
    <span class="n">subsets</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">subset</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="nb">len</span><span class="p">(</span><span class="n">set_</span><span class="p">)):</span>
        <span class="n">new_subset</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">bit</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">set_</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">is_bit_flipped</span><span class="p">(</span><span class="n">subset</span><span class="p">,</span> <span class="n">bit</span><span class="p">):</span>
                <span class="n">new_subset</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">set_</span><span class="p">[</span><span class="n">bit</span><span class="p">])</span>
        <span class="n">subsets</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_subset</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">subsets</span></code></pre></figure>

<hr />

<p><span id="note1"><a href="#link1">1</a></span>: (completely tangentially) whenever I mention set theory I can’t help but think of
the infamous <a href="http://en.wikipedia.org/wiki/Principia_Mathematica">Principia Mathematica</a>: a staggering, three-volume
attempt to axiomatize all of mathematics, published by <a href="http://en.wikipedia.org/wiki/Bertrand_Russell">Bertrand
Russell</a> and <a href="http://en.wikipedia.org/wiki/Alfred_North_Whitehead">Alfred North
Whitehead</a> in 1910-‘13, that relied heavily on sets. It’s
notorious, amongst other things, for proving \(1 + 1 = 2\) in no less than 379 pages. Check it out.</p>
:ET